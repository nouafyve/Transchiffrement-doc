En Java, pour manipuler des certificats, nous utilisons des objets de types keyStore.

Le keyStore doit contenir la clé privée et le certificat de l'application, dans notre cas, le proxy.

Dans notre cas, nous avons aussi besoin de reconnaître l'autorité qui a signé le certificat du site Web distant.

Ensuite, à chaque fois que l'utilisateur demande une connexion vers un site Web, il faut générer un certificat Fake-Cert. Ce certificat reprend les différentes informations du certificat authentique, à l'exception de la clé publique.

L'intérêt de la manipulation est de posséder la clé privée associée.

Le mot de passe du keyStore permet d'accéder au fichier physique du keyStore, puis de déchiffrer la clé privée stockée dans le keyStore.

Si nous ne définissons pas de keyStore, il en existe un par défaut, à l'emplacement :
\begin{verbatim}
$JAVA_HOME/lib/security/jssecacerts
\end{verbatim}
ou
\begin{verbatim}
$JAVA_HOME/lib/security/cacerts
\end{verbatim}


Un autre objet cryptographique en Java est le trustStore. Cet objet contient des certificats de CA à qui l'on fait confiance. Cette liste est semblable à celle que l'on peut trouver dans Firefox par exemple.

Pour résumer, nous stockons nos certificats dans le keyStore, et nous réutilisons les certificats d'autorité existants (par exemple Verisign) dans le trustore.


\paragraph{Handshake}

Le handshake désigne le processus de connexion du client avec le serveur.

Il peut être lancé explicitement si besoin, sinon il est implicitement appelé. Cet appel est réalisé avant toute première lecture ou écriture dans un des  flux entrant ou sortant de la socket.


C'est à cette étape que l'on vérifie si l'authentification est valide.


Le serveur TLS utilise sa clé privée lors de l'échange de clés.
Le serveur envoie le certificat du keyStore et la clé publique au client.

Pour manipuler le contenu du keyStore, nous utilisons l'utilitaire keytool.